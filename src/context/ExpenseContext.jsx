import React, { createContext, useState, useEffect, useContext } from 'react';
import { getAllExpenses, addExpenseToDB, deleteExpenseFromDB, updateExpenseInDB } from '../utils/db';

const ExpenseContext = createContext();

export const useExpenses = () => useContext(ExpenseContext);

export const ExpenseProvider = ({ children }) => {
  const [expenses, setExpenses] = useState([]);
  const [editingExpense, setEditingExpense] = useState(null);
  const [loading, setLoading] = useState(true);

  // Initialize DB and load expenses
  useEffect(() => {
    const initData = async () => {
      try {
        setLoading(true);

        // 1. Load from DB
        const dbExpenses = await getAllExpenses();

        // 2. Check for migration from localStorage
        const localExpenses = localStorage.getItem('expenses');
        if (localExpenses) {
          try {
            const parsedLocal = JSON.parse(localExpenses);
            if (Array.isArray(parsedLocal) && parsedLocal.length > 0) {
              // Add each local expense to DB if not already present
              // (Simple check: if DB is empty, or simple merge. Here we just add all to ensure no data loss)
              // Ideally we check by ID, but IDs might collide if generated by Date.now() at different times
              // For simplicity in this migration: Add only if DB is empty or just add them.
              // Let's iterate and add.
              for (const expense of parsedLocal) {
                // check if exists? IndexedDB add will fail if key exists.
                // using put (updateExpenseInDB) might be safer or just try/catch add
                try {
                  await addExpenseToDB(expense);
                } catch (e) {
                  console.log('Skipping duplicate or error during migration:', e);
                }
              }
              // Clear localStorage after successful migration attempt
              // localStorage.removeItem('expenses'); // Keeping it for safety for now, or clear it?
              // User asked "not to be cleared". Best to clear it to avoid double loading next time if logic changes,
              // but we only load from DB in step 1.
              // Let's clear it to mark migration done.
              localStorage.removeItem('expenses');

              // Refresh state from DB
              const updatedDbExpenses = await getAllExpenses();
              setExpenses(updatedDbExpenses);
            } else {
              setExpenses(dbExpenses);
            }
          } catch (e) {
            console.error("Migration error:", e);
            setExpenses(dbExpenses);
          }
        } else {
          setExpenses(dbExpenses);
        }

      } catch (error) {
        console.error("Failed to load expenses:", error);
      } finally {
        setLoading(false);
      }
    };

    initData();
  }, []);

  const addExpense = async (expense) => {
    const newExpense = { ...expense, id: Date.now() };
    // Optimistic UI update
    setExpenses((prevExpenses) => [...prevExpenses, newExpense]);
    try {
      await addExpenseToDB(newExpense);
    } catch (error) {
      console.error("Failed to add expense to DB:", error);
      // Rollback? For now, we assume simple success or refresh on reload.
    }
  };

  const deleteExpense = async (id) => {
    // Optimistic UI update
    setExpenses((prevExpenses) => prevExpenses.filter((expense) => expense.id !== id));
    try {
      await deleteExpenseFromDB(id);
    } catch (error) {
      console.error("Failed to delete expense from DB:", error);
    }
  };

  const editExpense = (expense) => {
    setEditingExpense(expense);
  };

  const updateExpense = async (updatedExpense) => {
    // Optimistic UI update
    setExpenses((prevExpenses) =>
      prevExpenses.map((expense) => (expense.id == updatedExpense.id ? updatedExpense : expense))
    );
    setEditingExpense(null);
    try {
      await updateExpenseInDB(updatedExpense);
    } catch (error) {
      console.error("Failed to update expense in DB:", error);
    }
  };

  const clearEditing = () => {
    setEditingExpense(null);
  };

  return (
    <ExpenseContext.Provider value={{ expenses, addExpense, deleteExpense, editingExpense, editExpense, updateExpense, clearEditing, loading }}>
      {children}
    </ExpenseContext.Provider>
  );
};
